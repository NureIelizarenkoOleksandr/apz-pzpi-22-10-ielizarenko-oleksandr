Міністерство освіти і науки України
Харківський національний університет радіоелектроніки
Кафедра програмної інженерії



Практична робота № 1


Виконав
Ст. гр. ПЗПІ-22-10
Єлізаренко Олександр
Андрійович

Перевірив
Ст. викл.
Сокорчук І. П.





2025







Слайд 1: Основні положення
Unit of Work — це патерн програмування, який використовується в шарі доступу до даних.
Він дозволяє координувати зміну декількох об'єктів у межах однієї транзакції та забезпечує цілісність і узгодженість змін у базі даних.
Основні положення:
* Патерн є частиною Domain-Driven Design (DDD).
* Він групує всі операції зі зміни стану об'єктів в одну логічну транзакцію.
* Найчастіше застосовується в поєднанні з репозиторним патерном.

Слайд 2: Яку проблему вирішує Unit of Work
Розробники часто працюють з кількома об'єктами моделі у рамках однієї бізнес-операції.
Без координації цих змін виникають такі проблеми:
Проблеми без Unit of Work:
* Множинні запити до БД — підвищене навантаження.
* Відсутність контрольованого збереження змін.
* У разі помилки частина змін вже збережена ? неконсистентність даних.
* Ускладнене тестування транзакційної логіки.

Слайд 3: Приклад без Unit of Work (Python + SQLAlchemy)
Якщо сталася помилка після додавання order, але до додавання item, в БД буде неповна інформація.

Слайд 4: Як працює Unit of Work
Unit of Work створює об'єкт, який:
1. Відстежує всі зміни до об'єктів.
2. Всі зміни зберігає разом в одній транзакції (commit).
3. У разі помилки скасовує всі зміни (rollback).
4. Є «менеджером змін» — координація між репозиторіями.

Слайд 5: Приклад з Unit of Work

Слайд 6: Архітектура Unit of Work
Компоненти:
* Репозиторії: працюють з об'єктами (OrderRepository, ProductRepository)
* Контекст/сесія: SQLAlchemy Session або аналог
* Unit of Work: об'єднує все та координує commit/rollback
 Потік:
1. Клієнт створює UnitOfWork.
2. Через UoW звертається до репозиторіїв.
3. UoW відстежує всі зміни.
4. При завершенні виконується commit() або rollback().



Слайд 7: Переваги використання
* Атомарність: усі зміни або зберігаються разом, або не зберігаються взагалі.
* Менше запитів до БД: зміни зберігаються пакетно.
* Тестованість: легше ізолювати бізнес-логіку.
* Чистий код: відокремлення збереження стану від логіки.
* Масштабованість: легше керувати великими транзакціями.

Слайд 8: Коли застосовувати Unit of Work
Використовуйте Unit of Work, якщо:
* Маєте складну бізнес-логіку з багатьма об'єктами.
* Потрібно узгоджено змінювати декілька сутностей.
* тести, де важлива ізоляція змін.
Не варто застосовувати, якщо:
* Просте CRUD-застосування.
* Немає необхідності у транзакційній цілісності.
* Застосунок не використовує ORM або змін мало.

Слайд 9: Висновки
* Unit of Work — потужний інструмент для управління змінами в БД.
* Дає контроль, узгодженість та гнучкість.
* Найкраще працює в парі з ORM (наприклад SQLAlchemy, Django ORM).
* Є ключовим патерном у DDD та enterprise-архітектурі.























Додаток А
Ютуб посилання: https://youtu.be/Xl0NWOkS0FE




























Додаток Б








































Додаток В
Код:
session = Session()

# Створюємо нове замовлення
order = Order(customer_id=1)
session.add(order)

# Додаємо товар
item = OrderItem(order_id=order.id, product_id=5, quantity=2)
session.add(item)

# Помилка тут може залишити order без item
session.commit()




class UnitOfWork:
    def __init__(self, session_factory):
        self.session = session_factory()

    def __enter__(self):
        return self

    def __exit__(self, *args):
        if any(args):
            self.session.rollback()
        else:
            self.session.commit()
        self.session.close()

    def commit(self):
        self.session.commit()

    def rollback(self):
        self.session.rollback()
Використання:
with UnitOfWork(Session) as uow:
    order = Order(customer_id=1)
    uow.session.add(order)

    item = OrderItem(order_id=order.id, product_id=5, quantity=2)
    uow.session.add(item)
    # commit() виконається автоматично або rollback() у разі помилки



